<hr />

<h2 id="async-first-philosophy">Async-First Philosophy</h2>

<p>cache-kit is built from the ground up as an <strong>async-first</strong> library. This design choice reflects the reality of modern Rust services where:</p>

<ul>
  <li>Database queries are async (SQLx, SeaORM, tokio-postgres)</li>
  <li>HTTP handlers are async (Axum, Actix, warp)</li>
  <li>gRPC services are async (tonic)</li>
  <li>Background workers are async (tokio, async-std)</li>
</ul>

<p>The cache layer sits between these components and must integrate seamlessly with async workflows.</p>

<hr />

<h2 id="tokio-runtime-integration">Tokio Runtime Integration</h2>

<p>cache-kit is designed for <code class="language-plaintext highlighter-rouge">tokio</code>-based applications. The library does not:</p>

<ul>
  <li>Spawn its own runtime</li>
  <li>Require a specific runtime configuration</li>
  <li>Impose threading models on your application</li>
</ul>

<p>Instead, cache-kit operates within <strong>your</strong> existing tokio runtime.</p>

<h3 id="runtime-requirements">Runtime Requirements</h3>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[dependencies]</span>
<span class="nn">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.41"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"rt"</span><span class="p">,</span> <span class="s">"sync"</span><span class="p">,</span> <span class="s">"macros"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">cache-kit</span> <span class="p">=</span> <span class="s">"0.9"</span>
</code></pre></div></div>

<p>The minimum required tokio features:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rt</code> — Runtime support</li>
  <li><code class="language-plaintext highlighter-rouge">sync</code> — Synchronization primitives (Arc, Mutex, RwLock)</li>
  <li><code class="language-plaintext highlighter-rouge">macros</code> — <code class="language-plaintext highlighter-rouge">#[tokio::main]</code> attribute macro</li>
</ul>

<hr />

<h2 id="interaction-model">Interaction Model</h2>

<p>The typical interaction flow follows this pattern:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Async Database → Async Cache → Async Application
</code></pre></div></div>

<h3 id="example-async-database-to-async-cache">Example: Async Database to Async Cache</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::{</span><span class="n">CacheEntity</span><span class="p">,</span> <span class="n">CacheFeed</span><span class="p">,</span> <span class="n">DataRepository</span><span class="p">,</span> <span class="n">CacheExpander</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::</span><span class="n">InMemoryBackend</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">strategy</span><span class="p">::</span><span class="n">CacheStrategy</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">sqlx</span><span class="p">::</span><span class="n">PgPool</span><span class="p">;</span>

<span class="c1">// Async repository using SQLx</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">UserRepository</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="n">PgPool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UserRepository</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">user</span> <span class="o">=</span> <span class="nn">sqlx</span><span class="p">::</span><span class="nn">query_as</span><span class="p">::</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">User</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="s">"SELECT * FROM users WHERE id = $1"</span>
        <span class="p">)</span>
        <span class="nf">.bind</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
        <span class="nf">.fetch_optional</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.pool</span><span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">RepositoryError</span><span class="p">(</span><span class="n">e</span><span class="nf">.to_string</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">PgPool</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="s">"postgres://localhost/mydb"</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">repo</span> <span class="o">=</span> <span class="n">UserRepository</span> <span class="p">{</span> <span class="n">pool</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">InMemoryBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span>
        <span class="n">id</span><span class="p">:</span> <span class="s">"user_001"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">user</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// Cache operation works seamlessly within async context</span>
    <span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="why-datarepository-is-async">Why DataRepository is Async</h2>

<p>The <code class="language-plaintext highlighter-rouge">DataRepository</code> trait uses <strong>async</strong> methods:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CacheEntity</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">T</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This design is intentional and provides several benefits:</p>

<h3 id="1-native-async-support">1. Native Async Support</h3>

<p>Async trait methods align with modern Rust practices and integrate seamlessly with async databases.</p>

<h3 id="2-flexibility">2. Flexibility</h3>

<p>You can use both sync and async database layers (see <a href="#handling-sync-code-in-async-repositories">Handling Sync Code</a> section below).</p>

<h3 id="3-backend-compatibility">3. Backend Compatibility</h3>

<p>Cache backends (Redis, Memcached) are inherently async, and the async trait ensures compatibility across all patterns.</p>

<hr />

<h2 id="handling-sync-code-in-async-repositories">Handling Sync Code in Async Repositories</h2>

<p>When you need to call synchronous code from an async <code class="language-plaintext highlighter-rouge">DataRepository</code>, use <code class="language-plaintext highlighter-rouge">tokio::task::spawn_blocking</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">ProductRepository</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// For truly blocking operations (e.g., sync database driver)</span>
        <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">conn</span> <span class="o">=</span> <span class="k">self</span><span class="py">.conn</span><span class="nf">.clone</span><span class="p">();</span>
        
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">spawn_blocking</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="n">conn</span><span class="nf">.query_row</span><span class="p">(</span><span class="s">"SELECT * FROM products WHERE id = ?"</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">id</span><span class="p">],</span> <span class="p">|</span><span class="n">row</span><span class="p">|</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">Product</span> <span class="p">{</span>
                    <span class="n">id</span><span class="p">:</span> <span class="n">row</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">:</span> <span class="n">row</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">RepositoryError</span><span class="p">(</span><span class="n">e</span><span class="nf">.to_string</span><span class="p">()))</span><span class="o">?</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="when-to-use-spawn_blocking">When to use spawn_blocking</h3>

<ul>
  <li><strong>Blocking synchronous database drivers</strong> (rusqlite, sqlite, etc.)</li>
  <li><strong>CPU-intensive operations</strong> that don’t yield</li>
  <li><strong>External system calls</strong> that block</li>
</ul>

<h3 id="️-avoid-block_in_place--block_on">⚠️ Avoid block_in_place + block_on</h3>

<p><strong>NEVER use <code class="language-plaintext highlighter-rouge">block_in_place</code> + <code class="language-plaintext highlighter-rouge">Handle::current().block_on()</code></strong> — this pattern is outdated. Use <code class="language-plaintext highlighter-rouge">async fn</code> directly or <code class="language-plaintext highlighter-rouge">spawn_blocking</code> for sync code.</p>

<hr />

<h2 id="async-cache-backends">Async Cache Backends</h2>

<p>Cache backends are fully async and follow the same initialization pattern:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Redis</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::{</span><span class="n">RedisBackend</span><span class="p">,</span> <span class="n">RedisConfig</span><span class="p">};</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span> <span class="n">url</span><span class="p">:</span> <span class="s">"redis://localhost:6379"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">RedisBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Memcached</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::{</span><span class="n">MemcachedBackend</span><span class="p">,</span> <span class="n">MemcachedConfig</span><span class="p">};</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">MemcachedConfig</span> <span class="p">{</span> <span class="n">servers</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"localhost:11211"</span><span class="nf">.to_string</span><span class="p">()],</span> <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span> <span class="p">};</span>
<span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">MemcachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// InMemory (lock-free via DashMap)</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::</span><span class="n">InMemoryBackend</span><span class="p">;</span>
<span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">InMemoryBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

<span class="c1">// All use the same expander API</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
</code></pre></div></div>

<p>All backends work seamlessly within your async context — no special handling required.</p>

<hr />

<h2 id="runtime-choice-is-yours">Runtime Choice is Yours</h2>

<p>cache-kit does not:</p>

<ul>
  <li>Require a specific tokio runtime configuration</li>
  <li>Spawn background tasks (no <code class="language-plaintext highlighter-rouge">tokio::spawn</code> calls)</li>
  <li>Create thread pools</li>
  <li>Impose executor choices</li>
</ul>

<p>You control:</p>

<ul>
  <li>Runtime flavor (multi-thread, current-thread)</li>
  <li>Worker thread count</li>
  <li>Task spawning strategy</li>
  <li>Shutdown behavior</li>
</ul>

<hr />

<h2 id="sync-support-not-recommended">Sync Support (Not Recommended)</h2>

<p>While cache-kit is async-first, you can use it in synchronous contexts if absolutely necessary by creating a runtime:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">runtime</span><span class="p">::</span><span class="n">Runtime</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">sync_cache_operation</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">runtime</span> <span class="o">=</span> <span class="nn">Runtime</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="n">runtime</span><span class="nf">.block_on</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">InMemoryBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
        
        <span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Or from within an existing async context:</span>
<span class="c1">// let handle = tokio::runtime::Handle::current();</span>
<span class="c1">// handle.block_on(async { ... })</span>
</code></pre></div></div>

<p><strong>Important:</strong> These patterns are provided for compatibility only. Async-first design is strongly recommended for production services.</p>

<hr />

<h2 id="best-practices">Best Practices</h2>

<h3 id="do">DO</h3>

<p>✅ Use <code class="language-plaintext highlighter-rouge">tokio::main</code> for your application entry point
✅ Make <code class="language-plaintext highlighter-rouge">DataRepository::fetch_by_id</code> an async function
✅ Use <code class="language-plaintext highlighter-rouge">spawn_blocking</code> for synchronous database drivers
✅ Let cache-kit operate within your existing runtime
✅ Keep async boundaries explicit and clear</p>

<h3 id="dont">DON’T</h3>

<p>❌ Use <code class="language-plaintext highlighter-rouge">block_in_place</code> + <code class="language-plaintext highlighter-rouge">block_on</code> (outdated pattern)
❌ Call <code class="language-plaintext highlighter-rouge">block_on</code> without <code class="language-plaintext highlighter-rouge">block_in_place</code> inside async contexts
❌ Create multiple tokio runtimes unnecessarily
❌ Mix sync and async code without proper bridging
❌ Assume cache-kit manages runtime lifecycle</p>

<hr />

<h2 id="example-full-async-service">Example: Full Async Service</h2>

<p>Here’s a complete example of a tokio-based service using cache-kit:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::{</span><span class="n">CacheEntity</span><span class="p">,</span> <span class="n">CacheFeed</span><span class="p">,</span> <span class="n">DataRepository</span><span class="p">,</span> <span class="n">CacheExpander</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::</span><span class="n">RedisBackend</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">strategy</span><span class="p">::</span><span class="n">CacheStrategy</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">axum</span><span class="p">::{</span><span class="n">Router</span><span class="p">,</span> <span class="nn">routing</span><span class="p">::</span><span class="n">get</span><span class="p">,</span> <span class="nn">extract</span><span class="p">::</span><span class="n">State</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">sqlx</span><span class="p">::</span><span class="n">PgPool</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="p">;</span>

<span class="c1">// Your entities, feeders, and repository implementations</span>

<span class="k">struct</span> <span class="n">AppState</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">CacheExpander</span><span class="o">&lt;</span><span class="n">RedisBackend</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">repo</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">UserRepository</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_user</span><span class="p">(</span>
    <span class="nf">State</span><span class="p">(</span><span class="n">state</span><span class="p">):</span> <span class="n">State</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">AppState</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="nn">axum</span><span class="p">::</span><span class="nn">extract</span><span class="p">::</span><span class="nf">Path</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span> <span class="nn">axum</span><span class="p">::</span><span class="nn">extract</span><span class="p">::</span><span class="n">Path</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span>
        <span class="n">id</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span>
        <span class="n">user</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">state</span><span class="py">.cache</span>
        <span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">state</span><span class="py">.repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="n">e</span><span class="nf">.to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"User: {:?}"</span><span class="p">,</span> <span class="n">feeder</span><span class="py">.user</span><span class="p">))</span>
<span class="p">}</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="c1">// Database setup</span>
    <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">PgPool</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="s">"postgres://localhost/mydb"</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">repo</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">UserRepository</span> <span class="p">{</span> <span class="n">pool</span> <span class="p">});</span>

    <span class="c1">// Cache setup</span>
    <span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">backend</span><span class="p">::</span><span class="nn">RedisConfig</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">RedisBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">));</span>

    <span class="c1">// Application state</span>
    <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">AppState</span> <span class="p">{</span> <span class="n">cache</span><span class="p">,</span> <span class="n">repo</span> <span class="p">});</span>

    <span class="c1">// HTTP server (async all the way)</span>
    <span class="k">let</span> <span class="n">app</span> <span class="o">=</span> <span class="nn">Router</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.route</span><span class="p">(</span><span class="s">"/users/:id"</span><span class="p">,</span> <span class="nf">get</span><span class="p">(</span><span class="n">get_user</span><span class="p">))</span>
        <span class="nf">.with_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">listener</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="s">"127.0.0.1:3000"</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nn">axum</span><span class="p">::</span><span class="nf">serve</span><span class="p">(</span><span class="n">listener</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="next-steps">Next Steps</h2>

<ul>
  <li>Learn about <a href="concepts">Core Concepts</a> in cache-kit</li>
  <li>Explore <a href="database-compatibility">Database &amp; ORM Compatibility</a></li>
  <li>Review the <a href="https://github.com/megamsys/cache-kit.rs/tree/main/examples/actixsqlx">Actix + SQLx reference implementation</a></li>
</ul>
