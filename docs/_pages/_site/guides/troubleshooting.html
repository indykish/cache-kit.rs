<h1 id="production-troubleshooting-guide">Production Troubleshooting Guide</h1>

<p>Diagnose and resolve cache-kit issues in production environments.</p>

<hr />

<h2 id="overview">Overview</h2>

<p>This guide covers the most common cache-kit issues, how to diagnose them, and how to fix them.</p>

<h3 id="diagnostic-workflow">Diagnostic Workflow</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Issue Observed
    ↓
Identify Category (Connection? Performance? Data?)
    ↓
Gather Logs &amp; Metrics
    ↓
Check Backend Health
    ↓
Apply Fix
    ↓
Verify Resolution
</code></pre></div></div>

<h3 id="tools-youll-need">Tools You’ll Need</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis diagnosis</span>
redis-cli
redis-cli <span class="nt">--latency</span>
redis-cli <span class="nt">--stat</span>

<span class="c"># Memcached diagnosis</span>
<span class="nb">echo</span> <span class="s2">"stats"</span> | nc localhost 11211
memcached-tool localhost:11211

<span class="c"># Application logs</span>
<span class="nb">grep</span> <span class="s2">"cache"</span> app.log | <span class="nb">grep</span> <span class="s2">"error"</span>

<span class="c"># System metrics</span>
top
vmstat
netstat
</code></pre></div></div>

<hr />

<h2 id="common-issues--solutions">Common Issues &amp; Solutions</h2>

<h3 id="issue-1-low-cache-hit-rate--30">Issue 1: Low Cache Hit Rate (&lt; 30%)</h3>

<p><strong>Symptoms:</strong></p>
<ul>
  <li>Hit rate stuck at 10-20%</li>
  <li>Cache size not growing</li>
  <li>High database load despite caching</li>
</ul>

<p><strong>Possible Causes:</strong></p>
<ol>
  <li>Keys are not being reused (different key each time)</li>
  <li>TTL is too short (entries expire quickly)</li>
  <li>Cache keys are non-deterministic</li>
  <li>Cache is being cleared unexpectedly</li>
  <li>New users/data not being cached</li>
</ol>

<h4 id="diagnosis-steps">Diagnosis Steps</h4>

<p><strong>Step 1: Check hit/miss rates</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">CacheMetrics</span> <span class="p">{</span>
    <span class="n">hits</span><span class="p">:</span> <span class="n">AtomicU64</span><span class="p">,</span>
    <span class="n">misses</span><span class="p">:</span> <span class="n">AtomicU64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CacheMetrics</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">hit_rate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="k">self</span><span class="py">.hits</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="k">self</span><span class="py">.misses</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>
        <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// In your metrics endpoint</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Cache hit rate: {:.1}%"</span><span class="p">,</span> <span class="n">metrics</span><span class="nf">.hit_rate</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.9</span><span class="na">.0</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Step 2: Verify cache keys are deterministic</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ Good: Same input always produces same key</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">User</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">()</span>  <span class="c1">// Deterministic</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ❌ Bad: Different keys for same entity</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">User</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="c1">// WRONG: Creates new key each time!</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.id</span><span class="p">,</span> <span class="nn">SystemTime</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Step 3: Check TTL configuration</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis: Check expiration times</span>
redis-cli TTL <span class="s2">"user:123"</span>
<span class="c"># Output: 3600 (seconds remaining)</span>
<span class="c"># Output: -1 (no expiration set - cache forever!)</span>
<span class="c"># Output: -2 (key doesn't exist)</span>

<span class="c"># If TTL is -1 or very short, that's your problem</span>
</code></pre></div></div>

<p><strong>Step 4: Verify cache strategy</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// If using CacheStrategy::Fresh instead of Refresh, you miss database writes</span>
<span class="c1">// ❌ Wrong: Always cache-only</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Fresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// ✅ Correct: Cache with database fallback</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="solutions">Solutions</h4>

<p><strong>Solution 1A: Set appropriate TTL</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: No TTL</span>
<span class="k">let</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>

<span class="c1">// After: 1-hour TTL for user data</span>
<span class="k">let</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
    <span class="nf">.with_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
    <span class="nf">.with_ttl</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">3600</span><span class="p">))</span>
    <span class="nf">.build</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>Solution 1B: Use Refresh strategy</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ensure using Refresh, not Fresh</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="c1">//              ↑ Try cache first, fallback to DB if miss</span>
</code></pre></div></div>

<p><strong>Solution 1C: Verify key uniqueness</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Log all cache keys to find issues</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">User</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"Cache key for user: {}"</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>  <span class="c1">// Add this</span>
        <span class="n">key</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Check logs for duplicate/varying keys</span>
<span class="n">grep</span> <span class="s">"Cache key for user"</span> <span class="n">app</span><span class="py">.log</span> <span class="p">|</span> <span class="n">sort</span> <span class="p">|</span> <span class="n">uniq</span> <span class="o">-</span><span class="n">c</span>
</code></pre></div></div>

<p><strong>Solution 1D: Check for cache invalidation logic</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Verify you're not over-invalidating</span>
<span class="c1">// This is correct: Invalidate on write</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_user</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">user</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">User</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// 1. Update database</span>
    <span class="k">self</span><span class="py">.repo</span><span class="nf">.update</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="c1">// 2. Invalidate OLD version</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">user</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">user</span><span class="p">:</span> <span class="nb">None</span> <span class="p">};</span>
    <span class="k">self</span><span class="py">.cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="c1">// 3. Cache NEW version</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">user</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">user</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">user</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">};</span>
    <span class="k">self</span><span class="py">.cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="issue-2-backend-connection-timeouts">Issue 2: Backend Connection Timeouts</h3>

<p><strong>Symptoms:</strong></p>
<ul>
  <li>Request timeouts after N milliseconds</li>
  <li>“Connection refused” errors</li>
  <li>Pool exhaustion errors</li>
  <li>p99 latency spikes</li>
</ul>

<p><strong>Possible Causes:</strong></p>
<ol>
  <li>Backend (Redis/Memcached) is down</li>
  <li>Network connectivity issue</li>
  <li>Connection pool size is too small</li>
  <li>Timeout is set too aggressively</li>
</ol>

<h4 id="diagnosis-steps-1">Diagnosis Steps</h4>

<p><strong>Step 1: Verify backend is running</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis</span>
redis-cli ping
<span class="c"># Response: PONG (good)</span>
<span class="c"># Response: (error) ERR... (bad - Redis down)</span>

<span class="c"># Memcached</span>
<span class="nb">echo</span> <span class="s2">"stats"</span> | nc <span class="nt">-w</span> 1 localhost 11211
<span class="c"># Response: STAT... (good)</span>
<span class="c"># No response or error (bad - Memcached down)</span>
</code></pre></div></div>

<p><strong>Step 2: Check network connectivity</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Test network path</span>
nc <span class="nt">-zv</span> localhost 6379
<span class="c"># Connected to localhost port 6379 (good)</span>
<span class="c"># Connection refused (network issue)</span>

<span class="c"># Check latency</span>
redis-cli <span class="nt">--latency</span>
<span class="c"># Typical latency: &lt; 1ms (good)</span>
<span class="c"># Typical latency: &gt; 10ms (slow network)</span>
</code></pre></div></div>

<p><strong>Step 3: Examine connection pool status</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Monitor pool metrics</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PoolMetrics</span> <span class="p">{</span>
    <span class="n">active_connections</span><span class="p">:</span> <span class="n">AtomicU64</span><span class="p">,</span>
    <span class="n">waiting_requests</span><span class="p">:</span> <span class="n">AtomicU64</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Log pool status on errors</span>
<span class="k">match</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{},</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"pool"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">error!</span><span class="p">(</span>
            <span class="s">"Pool exhausted: {} active, {} waiting"</span><span class="p">,</span>
            <span class="n">metrics</span><span class="py">.active_connections</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">),</span>
            <span class="n">metrics</span><span class="py">.waiting_requests</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">error!</span><span class="p">(</span><span class="s">"Cache error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Step 4: Check timeout configuration</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Current timeout</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span>
    <span class="n">connection_timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
    <span class="c1">// Is this too short for your network?</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="solutions-1">Solutions</h4>

<p><strong>Solution 2A: Restart backend</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis</span>
redis-cli shutdown
redis-server

<span class="c"># Or with Docker</span>
docker restart redis_container
</code></pre></div></div>

<p><strong>Solution 2B: Increase pool size</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: Small pool</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span>
    <span class="n">pool_size</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
<span class="p">};</span>

<span class="c1">// After: Formula (CPU_cores × 2) + 1</span>
<span class="k">let</span> <span class="n">cores</span> <span class="o">=</span> <span class="nn">num_cpus</span><span class="p">::</span><span class="nf">get</span><span class="p">();</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span>
    <span class="n">pool_size</span><span class="p">:</span> <span class="p">(</span><span class="n">cores</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>Solution 2C: Increase timeout</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: Very strict timeout</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span>
    <span class="n">connection_timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
<span class="p">};</span>

<span class="c1">// After: More realistic</span>
<span class="k">let</span> <span class="n">config</span> <span class="o">=</span> <span class="n">RedisConfig</span> <span class="p">{</span>
    <span class="n">connection_timeout</span><span class="p">:</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>Solution 2D: Add circuit breaker</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// See Error Handling guide for circuit breaker implementation</span>
<span class="c1">// This prevents cascading failures when backend is slow</span>
<span class="k">let</span> <span class="n">breaker</span> <span class="o">=</span> <span class="nn">CircuitBreaker</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>
</code></pre></div></div>

<hr />

<h3 id="issue-3-high-memory-usage">Issue 3: High Memory Usage</h3>

<p><strong>Symptoms:</strong></p>
<ul>
  <li>Cache backend consuming GB of RAM</li>
  <li>OOM killer triggering</li>
  <li>Eviction errors from backend</li>
  <li>Request latency increasing</li>
</ul>

<p><strong>Possible Causes:</strong></p>
<ol>
  <li>Entries are too large (whole objects)</li>
  <li>TTL not set (entries never expire)</li>
  <li>Too many unique keys (unbounded growth)</li>
  <li>No eviction policy configured</li>
  <li>Memory leak in application</li>
</ol>

<h4 id="diagnosis-steps-2">Diagnosis Steps</h4>

<p><strong>Step 1: Check Redis memory usage</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli INFO memory
<span class="c"># Output:</span>
<span class="c"># used_memory_human:2.5G  ← How much is being used</span>
<span class="c"># maxmemory:3G            ← Maximum allowed</span>
<span class="c"># evicted_keys:1000       ← Keys removed due to eviction</span>
</code></pre></div></div>

<p><strong>Step 2: Estimate entry size</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli <span class="nt">--bigkeys</span>
<span class="c"># Output:</span>
<span class="c"># Scanning database...</span>
<span class="c"># [Hash] "employment:123" -&gt; 512 bytes</span>
<span class="c"># [String] "user:456" -&gt; 128 bytes</span>

<span class="c"># If entries are 512+ bytes, consider smaller DTOs</span>
</code></pre></div></div>

<p><strong>Step 3: Analyze key count</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli DBSIZE
<span class="c"># Output: 5000000</span>
<span class="c"># With 1KB entries: 5GB of data</span>
<span class="c"># Check if all keys are needed</span>
</code></pre></div></div>

<p><strong>Step 4: Check eviction policy</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli CONFIG GET maxmemory-policy
<span class="c"># Output: "allkeys-lru" (good - evicts least recently used)</span>
<span class="c"># Output: "no-eviction" (bad - rejects new writes when full)</span>
</code></pre></div></div>

<h4 id="solutions-2">Solutions</h4>

<p><strong>Solution 3A: Set appropriate TTL</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: Cache forever</span>
<span class="k">let</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>

<span class="c1">// After: 1-hour TTL for users, 1-day for products</span>
<span class="k">let</span> <span class="n">user_cache</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
    <span class="nf">.with_backend</span><span class="p">(</span><span class="n">redis_backend</span><span class="p">)</span>
    <span class="nf">.with_ttl</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">3600</span><span class="p">))</span>  <span class="c1">// 1 hour</span>
    <span class="nf">.build</span><span class="p">();</span>

<span class="k">let</span> <span class="n">product_cache</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
    <span class="nf">.with_backend</span><span class="p">(</span><span class="n">redis_backend</span><span class="p">)</span>
    <span class="nf">.with_ttl</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">86400</span><span class="p">))</span>  <span class="c1">// 1 day</span>
    <span class="nf">.build</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>Solution 3B: Reduce entry size</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: Cache entire User with all fields</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">CachedUser</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">password_hash</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>    <span class="c1">// Unnecessary in cache</span>
    <span class="n">profile_picture</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// Too large</span>
    <span class="n">bio</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">preferences</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// Heavy</span>
<span class="p">}</span>

<span class="c1">// After: Cache only needed fields</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">CachedUser</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="c1">// Skip: password, picture, preferences</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Solution 3C: Limit cache size</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis: Set maximum memory</span>
redis-cli CONFIG SET maxmemory 2gb
redis-cli CONFIG SET maxmemory-policy allkeys-lru

<span class="c"># Memcached: Set maximum memory at startup</span>
memcached <span class="nt">-m</span> 2048  <span class="c"># 2GB</span>
</code></pre></div></div>

<p><strong>Solution 3D: Monitor key count</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Alert if key count grows unbounded</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">check_cache_health</span><span class="p">(</span><span class="n">metrics</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Metrics</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key_count</span> <span class="o">=</span> <span class="nf">get_redis_dbsize</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="n">key_count</span> <span class="o">&gt;</span> <span class="n">ALERT_THRESHOLD</span> <span class="p">{</span>
        <span class="nd">alert!</span><span class="p">(</span><span class="s">"Cache size growing: {} keys"</span><span class="p">,</span> <span class="n">key_count</span><span class="p">);</span>
        <span class="c1">// Investigate: Are keys not expiring?</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="issue-4-serialization-errors">Issue 4: Serialization Errors</h3>

<p><strong>Symptoms:</strong></p>
<ul>
  <li>“Serialization failed” errors</li>
  <li>“Version mismatch” errors</li>
  <li>“Invalid magic header” errors</li>
  <li>Some requests fail, others work</li>
</ul>

<p><strong>Possible Causes:</strong></p>
<ol>
  <li>Entity type changed (schema mismatch)</li>
  <li>Corrupted cache entry</li>
  <li>Type contains unsupported fields (e.g., Decimal)</li>
  <li>Different serialization formats</li>
</ol>

<h4 id="diagnosis-steps-3">Diagnosis Steps</h4>

<p><strong>Step 1: Check error logs</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"serialization"</span> app.log | <span class="nb">head</span> <span class="nt">-20</span>
<span class="c"># Output:</span>
<span class="c"># 2024-01-15 10:23:45 WARN: Serialization failed for user:123: Unsupported type</span>
</code></pre></div></div>

<p><strong>Step 2: Identify affected entities</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"serialization"</span> app.log | <span class="nb">grep</span> <span class="nt">-o</span> <span class="s2">"user:[0-9]*"</span> | <span class="nb">sort</span> | <span class="nb">uniq</span>
<span class="c"># Output: user:123, user:456, user:789</span>
<span class="c"># All from same key? Different ones? Pattern?</span>
</code></pre></div></div>

<p><strong>Step 3: Check entity definition</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Look for unsupported types</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">balance</span><span class="p">:</span> <span class="nn">rust_decimal</span><span class="p">::</span><span class="n">Decimal</span><span class="p">,</span>  <span class="c1">// ❌ Not supported by Postcard!</span>
<span class="p">}</span>

<span class="c1">// Or type changed</span>
<span class="c1">// Version 1:</span>
<span class="c1">// struct User { id: String, name: String }</span>
<span class="c1">// Version 2:</span>
<span class="c1">// struct User { id: String, name: String, email: String }  // Added field!</span>
</code></pre></div></div>

<h4 id="solutions-3">Solutions</h4>

<p><strong>Solution 4A: Clear affected entries</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Redis: Delete specific key</span>
redis-cli DEL <span class="s2">"user:123"</span>

<span class="c"># Or delete all of a type</span>
redis-cli KEYS <span class="s2">"user:*"</span> | xargs redis-cli DEL

<span class="c"># Memcached</span>
<span class="nb">echo</span> <span class="s2">"delete user:123"</span> | nc localhost 11211
</code></pre></div></div>

<p><strong>Solution 4B: Replace Decimal with i64</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before: Uses Decimal</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">CachedProduct</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">price</span><span class="p">:</span> <span class="nn">rust_decimal</span><span class="p">::</span><span class="n">Decimal</span><span class="p">,</span>  <span class="c1">// ❌ Not serializable</span>
<span class="p">}</span>

<span class="c1">// After: Use integer cents</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">CachedProduct</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">price_cents</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>  <span class="c1">// ✅ Serializable</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CachedProduct</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">price</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.price_cents</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="mf">0.9</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Solution 4C: Use cache-specific DTO</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Database type (with Decimal)</span>
<span class="nd">#[derive(sqlx::FromRow)]</span>
<span class="k">struct</span> <span class="n">ProductRow</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">price</span><span class="p">:</span> <span class="nn">rust_decimal</span><span class="p">::</span><span class="n">Decimal</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Cache type (with i64)</span>
<span class="nd">#[derive(Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">CachedProduct</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">price_cents</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">ProductRow</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">CachedProduct</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="n">ProductRow</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">CachedProduct</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="n">row</span><span class="py">.id</span><span class="p">,</span>
            <span class="n">price_cents</span><span class="p">:</span> <span class="p">(</span><span class="n">row</span><span class="py">.price</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span><span class="nf">.to_i64</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="logging-setup">Logging Setup</h2>

<h3 id="configure-log-levels">Configure Log Levels</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In your main.rs or lib.rs</span>
<span class="k">use</span> <span class="n">tracing_subscriber</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Development: DEBUG level</span>
    <span class="nd">#[cfg(debug_assertions)]</span>
    <span class="p">{</span>
        <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
            <span class="nf">.with_max_level</span><span class="p">(</span><span class="nn">Level</span><span class="p">::</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="nf">.init</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Production: INFO level (less verbose)</span>
    <span class="nd">#[cfg(not(debug_assertions))]</span>
    <span class="p">{</span>
        <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
            <span class="nf">.with_max_level</span><span class="p">(</span><span class="nn">Level</span><span class="p">::</span><span class="n">INFO</span><span class="p">)</span>
            <span class="nf">.init</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="environment-variable-configuration">Environment Variable Configuration</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Enable debug logging</span>
<span class="nv">RUST_LOG</span><span class="o">=</span><span class="nv">cache</span><span class="o">=</span>debug cargo run

<span class="c"># Cache-kit only</span>
<span class="nv">RUST_LOG</span><span class="o">=</span><span class="nv">cache_kit</span><span class="o">=</span>trace cargo run

<span class="c"># Everything</span>
<span class="nv">RUST_LOG</span><span class="o">=</span>debug cargo run
</code></pre></div></div>

<h3 id="structured-logging">Structured Logging</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tracing</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">debug</span><span class="p">};</span>

<span class="c1">// ✅ Good: Structured, searchable logs</span>
<span class="nd">info!</span><span class="p">(</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="o">%</span><span class="n">user_id</span><span class="p">,</span>
    <span class="n">cache_hit</span> <span class="o">=</span> <span class="n">hit</span><span class="p">,</span>
    <span class="n">latency_ms</span> <span class="o">=</span> <span class="n">latency</span><span class="nf">.as_millis</span><span class="p">(),</span>
    <span class="s">"Cache operation completed"</span>
<span class="p">);</span>

<span class="c1">// ❌ Bad: Unstructured, hard to parse</span>
<span class="nd">info!</span><span class="p">(</span><span class="s">"Cache operation for user {} completed in {:?}ms"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">latency</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="common-log-patterns">Common Log Patterns</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ Cache hit (expected):
    info!("Cache hit for user:{}", user_id);

✅ Cache miss (expected):
    debug!("Cache miss for user:{}, fetching from DB", user_id);

✅ Backend error (expected but needs handling):
    warn!("Cache backend unavailable: {}, using fallback", error);

❌ Serialization error (unexpected):
    error!("Serialization error for user:{}: {}", user_id, error);

❌ Pool exhausted (capacity issue):
    error!("Connection pool exhausted: {} active, {} waiting", active, waiting);
</code></pre></div></div>

<hr />

<h2 id="health-checks">Health Checks</h2>

<h3 id="backend-health-check-implementation">Backend Health Check Implementation</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">check_cache_health</span><span class="p">(</span>
    <span class="n">cache</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">CacheExpander</span><span class="o">&lt;</span><span class="n">RedisBackend</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HealthStatus</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>

    <span class="k">match</span> <span class="n">cache</span><span class="nf">.health_check</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">latency</span> <span class="o">=</span> <span class="n">start</span><span class="nf">.elapsed</span><span class="p">();</span>
            <span class="nd">info!</span><span class="p">(</span><span class="s">"Cache healthy, latency: {:?}"</span><span class="p">,</span> <span class="n">latency</span><span class="p">);</span>
            
            <span class="k">if</span> <span class="n">latency</span> <span class="o">&gt;</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">warn!</span><span class="p">(</span><span class="s">"Cache is slow: {:?}"</span><span class="p">,</span> <span class="n">latency</span><span class="p">);</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Degraded</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Healthy</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">error!</span><span class="p">(</span><span class="s">"Cache health check failed"</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Unhealthy</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">error!</span><span class="p">(</span><span class="s">"Health check error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="periodic-health-monitoring">Periodic Health Monitoring</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">monitor_cache_health</span><span class="p">(</span>
    <span class="n">cache</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">CacheExpander</span><span class="o">&lt;</span><span class="n">RedisBackend</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.lock</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
            <span class="k">match</span> <span class="nf">check_cache_health</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="k">.await</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Healthy</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug!</span><span class="p">(</span><span class="s">"Cache health: OK"</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Degraded</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">warn!</span><span class="p">(</span><span class="s">"Cache health: DEGRADED (slow responses)"</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">HealthStatus</span><span class="p">::</span><span class="n">Unhealthy</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">error!</span><span class="p">(</span><span class="s">"Cache health: DOWN"</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">error!</span><span class="p">(</span><span class="s">"Health check failed: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="expose-health-endpoint">Expose Health Endpoint</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Axum example</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">health_check</span><span class="p">(</span>
    <span class="nf">State</span><span class="p">(</span><span class="n">cache</span><span class="p">):</span> <span class="n">State</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">CacheExpander</span><span class="o">&lt;</span><span class="n">RedisBackend</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">IntoResponse</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.lock</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">cache</span><span class="nf">.health_check</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Json</span><span class="p">(</span><span class="nn">serde_json</span><span class="p">::</span><span class="nd">json!</span><span class="p">({</span>
            <span class="s">"status"</span><span class="p">:</span> <span class="s">"healthy"</span><span class="p">,</span>
            <span class="s">"cache"</span><span class="p">:</span> <span class="s">"ready"</span>
        <span class="p">})),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span>
            <span class="nn">StatusCode</span><span class="p">::</span><span class="n">SERVICE_UNAVAILABLE</span><span class="p">,</span>
            <span class="nf">Json</span><span class="p">(</span><span class="nn">serde_json</span><span class="p">::</span><span class="nd">json!</span><span class="p">({</span>
                <span class="s">"status"</span><span class="p">:</span> <span class="s">"unhealthy"</span><span class="p">,</span>
                <span class="s">"cache"</span><span class="p">:</span> <span class="s">"unavailable"</span>
            <span class="p">})),</span>
        <span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// In router</span>
<span class="n">app</span><span class="nf">.route</span><span class="p">(</span><span class="s">"/health"</span><span class="p">,</span> <span class="nf">get</span><span class="p">(</span><span class="n">health_check</span><span class="p">))</span>
</code></pre></div></div>

<hr />

<h2 id="production-troubleshooting-checklist">Production Troubleshooting Checklist</h2>

<p>Use this checklist when issues occur:</p>

<h3 id="cache-issues">Cache Issues</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is Redis/Memcached running? (<code class="language-plaintext highlighter-rouge">redis-cli ping</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is network connectivity OK? (<code class="language-plaintext highlighter-rouge">nc -zv localhost 6379</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are connection pool metrics available?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />What’s the hit rate? (&lt; 20% = investigate TTL/keys)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are there serialization errors? (check entity types)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is memory usage growing unbounded? (check TTL)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are cache keys deterministic? (check key generation)</li>
</ul>

<h3 id="network-issues">Network Issues</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is backend reachable? (<code class="language-plaintext highlighter-rouge">netstat</code> or <code class="language-plaintext highlighter-rouge">ss</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />What’s the latency? (<code class="language-plaintext highlighter-rouge">redis-cli --latency</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are there packet drops? (<code class="language-plaintext highlighter-rouge">netstat -s</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is there network congestion?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Did firewall rules change?</li>
</ul>

<h3 id="application-issues">Application Issues</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are error logs being generated? (<code class="language-plaintext highlighter-rouge">grep error app.log</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is the cache fallback code working?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are metrics being exported?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Is the database under load?</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Did schema change recently?</li>
</ul>

<h3 id="system-issues">System Issues</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />CPU usage normal? (<code class="language-plaintext highlighter-rouge">top</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Memory usage normal? (<code class="language-plaintext highlighter-rouge">free -h</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Disk space available? (<code class="language-plaintext highlighter-rouge">df -h</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />System load average? (<code class="language-plaintext highlighter-rouge">uptime</code>)</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Are there OOM killings? (<code class="language-plaintext highlighter-rouge">dmesg | tail</code>)</li>
</ul>

<hr />

<h2 id="getting-help">Getting Help</h2>

<p>If you can’t resolve the issue:</p>

<ol>
  <li><strong>Gather diagnostics:</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis-cli INFO server <span class="o">&gt;</span> redis_info.txt
redis-cli DBSIZE <span class="o">&gt;</span> redis_size.txt
top <span class="nt">-b</span> <span class="nt">-n</span> 1 <span class="o">&gt;</span> system_info.txt
<span class="nb">grep</span> <span class="nt">-i</span> cache app.log <span class="o">&gt;</span> cache_logs.txt
</code></pre></div>    </div>
  </li>
  <li><strong>Check recent changes:</strong>
    <ul>
      <li>Code deploy?</li>
      <li>Config change?</li>
      <li>Infrastructure change?</li>
      <li>Data volume increase?</li>
    </ul>
  </li>
  <li><strong>Enable debug logging:</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">RUST_LOG</span><span class="o">=</span><span class="nv">cache</span><span class="o">=</span>debug,cache_kit<span class="o">=</span>trace cargo run
</code></pre></div>    </div>
  </li>
  <li><strong>Open an issue:</strong> https://github.com/megamsys/cache-kit.rs/issues</li>
</ol>

<hr />

<hr />

<h2 id="error-handling-best-practices">Error Handling Best Practices</h2>

<h3 id="do-">DO ✅</h3>

<p><strong>1. Handle cache errors gracefully</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Good: Don't crash on cache errors</span>
<span class="k">match</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Use cached data from feeder</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">feeder</span><span class="py">.user</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Cache failed - fallback to database</span>
        <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Cache error: {}, using fallback"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="n">repo</span><span class="nf">.fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_id</span><span class="p">)</span><span class="nf">.ok</span><span class="p">()</span><span class="nf">.flatten</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>2. Log cache errors separately</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Good: Log with context</span>
<span class="k">match</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">info!</span><span class="p">(</span><span class="s">"Cache operation successful"</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">error!</span><span class="p">(</span><span class="s">"Cache error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>  <span class="c1">// Separate from app logic</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3. Use Result types properly</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Good: Propagate errors with context</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_user</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Use ? operator</span>
    <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">feeder</span><span class="py">.user</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span><span class="o">?</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Bad: Swallowing errors silently</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_user</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
    <span class="n">feeder</span><span class="py">.user</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>4. Distinguish cache errors from application errors</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Good: Different handling for different error types</span>
<span class="k">match</span> <span class="n">cache_result</span> <span class="p">{</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">BackendError</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">fallback_to_database</span><span class="p">(),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">SerializationError</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">invalidate_and_refetch</span><span class="p">(),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">TimeoutError</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">use_stale_data</span><span class="p">(),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">use_fresh_data</span><span class="p">(),</span>
<span class="p">}</span>

<span class="c1">// Bad: Treat all errors the same</span>
<span class="k">if</span> <span class="n">cache_result</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Cache failed!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>5. Test error paths thoroughly</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_cache_error_fallback</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">FailingBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>  <span class="c1">// Always fails</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
    
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">get_user_with_fallback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="s">"123"</span><span class="nf">.to_string</span><span class="p">());</span>
    
    <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_ok</span><span class="p">());</span>  <span class="c1">// Still works despite backend failure</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">expected_user</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="dont-">DON’T ❌</h3>

<p><strong>1. Panic on cache errors</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad: Crashes the service</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span>
    <span class="nf">.expect</span><span class="p">(</span><span class="s">"Cache must work!"</span><span class="p">);</span>  <span class="c1">// 💥 Production incident</span>

<span class="c1">// Good: Handle gracefully</span>
<span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span>
    <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Cache error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">));</span>
</code></pre></div></div>

<p><strong>2. Expose cache errors to users</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad: User sees internal error</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_user</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">User</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">feeder</span><span class="py">.user</span><span class="nf">.ok_or_else</span><span class="p">(||</span> <span class="s">"Cache error: serialization failed"</span><span class="nf">.to_string</span><span class="p">())</span><span class="o">?</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Good: Return user-friendly error</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">get_user</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="nd">error!</span><span class="p">(</span><span class="s">"Cache error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>  <span class="c1">// Log internally</span>
            <span class="nn">StatusCode</span><span class="p">::</span><span class="n">INTERNAL_SERVER_ERROR</span>  <span class="c1">// Return generic error</span>
        <span class="p">})</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">feeder</span><span class="py">.user</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span><span class="o">?</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3. Ignore all errors equally</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad: All errors treated the same</span>
<span class="k">if</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="nf">.is_ok</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">feeder</span><span class="py">.user</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nf">database_fallback</span><span class="p">();</span>

<span class="c1">// Good: Different handling per error</span>
<span class="k">match</span> <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">feeder</span><span class="py">.user</span><span class="p">,</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">BackendError</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">database_fallback</span><span class="p">(),</span>  <span class="c1">// Try DB</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">SerializationError</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>  <span class="c1">// Clear and refetch</span>
        <span class="n">cache</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
        <span class="nf">database_fallback</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Unexpected error: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>4. Cascade failures across services</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad: Cache failure blocks all dependent services</span>
<span class="n">service1</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">cache</span> <span class="err">❌</span>
<span class="n">service2</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">service1</span> <span class="err">❌</span>
<span class="n">service3</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">service2</span> <span class="err">❌</span>
<span class="c1">// If cache fails, everything fails</span>

<span class="c1">// Good: Each service has its own fallback</span>
<span class="n">service1</span> <span class="n">has</span> <span class="n">fallback</span> <span class="n">to</span> <span class="n">DB</span> <span class="err">✅</span>
<span class="n">service2</span> <span class="n">has</span> <span class="n">fallback</span> <span class="n">to</span> <span class="n">API</span> <span class="err">✅</span>
<span class="n">service3</span> <span class="n">has</span> <span class="n">fallback</span> <span class="n">to</span> <span class="n">queue</span> <span class="err">✅</span>
<span class="c1">// If any fails, others continue</span>
</code></pre></div></div>

<p><strong>5. Log sensitive data in error messages</strong></p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Bad: Logs contain user data</span>
<span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">error!</span><span class="p">(</span><span class="s">"Failed to cache user: {:?}"</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>  <span class="c1">// 🔓 Sensitive data</span>
<span class="p">}</span>

<span class="c1">// Good: Only log IDs</span>
<span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">error!</span><span class="p">(</span><span class="s">"Failed to cache user {}: {}"</span><span class="p">,</span> <span class="n">user</span><span class="py">.id</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>  <span class="c1">// ✅ Safe</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="next-steps">Next Steps</h2>

<ul>
  <li>Set up <a href="monitoring">Monitoring and metrics</a> to detect issues early</li>
  <li>Check <a href="performance">Performance tuning</a> for optimization</li>
</ul>

<hr />

<h2 id="see-also">See Also</h2>

<ul>
  <li><a href="monitoring">Monitoring Guide</a> — Set up metrics and alerting</li>
  <li><a href="../backends">Cache Backends</a> — Backend-specific configuration</li>
</ul>
