<hr />

<h2 id="overview">Overview</h2>

<p>cache-kit is built around four core concepts that work together to provide clean, explicit caching boundaries:</p>

<ol>
  <li><strong>Serializable Entities</strong> — Type-safe data models</li>
  <li><strong>Deterministic Cache Keys</strong> — Consistent, predictable addressing</li>
  <li><strong>Explicit Cache Boundaries</strong> — Clear ownership and behavior</li>
  <li><strong>Cache Invalidation Control</strong> — You decide when data becomes stale</li>
</ol>

<p>These concepts are <strong>intentionally simple</strong> and avoid framework-specific abstractions.</p>

<hr />

<h2 id="serializable-entities">Serializable Entities</h2>

<p>An entity in cache-kit is any Rust type that can be:</p>

<ol>
  <li><strong>Serialized</strong> to bytes (for storage in cache)</li>
  <li><strong>Deserialized</strong> from bytes (for retrieval from cache)</li>
  <li><strong>Cloned</strong> (for internal cache operations)</li>
  <li><strong>Identified</strong> by a unique key</li>
</ol>

<h3 id="the-cacheentity-trait">The CacheEntity Trait</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="n">CacheEntity</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="nd">#[derive(Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">User</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">cache_prefix</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="s">"user"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="what-makes-an-entity-cacheable">What Makes an Entity Cacheable?</h3>

<table>
  <thead>
    <tr>
      <th>Requirement</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Clone</code></td>
      <td>Cache operations need to duplicate entities</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Serialize</code></td>
      <td>Convert to bytes for storage</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Deserialize</code></td>
      <td>Convert from bytes for retrieval</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Send + Sync</code></td>
      <td>Safe to share across threads</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cache_key()</code></td>
      <td>Unique identifier for this entity</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cache_prefix()</code></td>
      <td>Namespace for entity type</td>
    </tr>
  </tbody>
</table>

<h3 id="cache-key-construction">Cache Key Construction</h3>

<p>The final cache key is constructed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{prefix}:{key}
</code></pre></div></div>

<p>For the User example above:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">user</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="s">"user_001"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="n">name</span><span class="p">:</span> <span class="s">"Alice"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="n">email</span><span class="p">:</span> <span class="s">"alice@example.com"</span><span class="nf">.to_string</span><span class="p">(),</span>
<span class="p">};</span>

<span class="c1">// Final cache key: "user:user_001"</span>
</code></pre></div></div>

<p>This pattern ensures:</p>
<ul>
  <li><strong>No collisions</strong> between different entity types</li>
  <li><strong>Predictable keys</strong> for debugging and monitoring</li>
  <li><strong>Type safety</strong> at compile time</li>
</ul>

<hr />

<h2 id="deterministic-cache-keys">Deterministic Cache Keys</h2>

<p>Cache keys must be <strong>deterministic</strong> — given the same entity, you always get the same key.</p>

<h3 id="good-key-examples">Good Key Examples</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ✅ Simple ID</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">User</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ✅ Composite key</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">OrderItem</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.order_id</span><span class="p">,</span> <span class="k">self</span><span class="py">.item_id</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ✅ Numeric ID</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">Product</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.product_id</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="anti-patterns-to-avoid">Anti-Patterns to Avoid</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ Non-deterministic (timestamp)</span>
<span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.id</span><span class="p">,</span> <span class="nn">SystemTime</span><span class="p">::</span><span class="nf">now</span><span class="p">()</span><span class="nf">.timestamp</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// ❌ Non-deterministic (random)</span>
<span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.id</span><span class="p">,</span> <span class="nn">rand</span><span class="p">::</span><span class="nn">random</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// ❌ Overly complex (hash collisions possible)</span>
<span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{:x}"</span><span class="p">,</span> <span class="nf">calculate_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Rule:</strong> Cache keys should depend <strong>only</strong> on stable entity attributes.</p>

<hr />

<h2 id="explicit-cache-boundaries">Explicit Cache Boundaries</h2>

<p>cache-kit uses a <strong>feeder pattern</strong> to define explicit cache boundaries.</p>

<h3 id="the-cachefeed-trait">The CacheFeed Trait</h3>

<p>A feeder acts as a bridge between cache-kit and your application:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="n">CacheFeed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">UserFeeder</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">user</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CacheFeed</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UserFeeder</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">entity_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">feed</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.user</span> <span class="o">=</span> <span class="n">entity</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="why-feeders">Why Feeders?</h3>

<p>Feeders provide several benefits:</p>

<ol>
  <li><strong>Explicit data flow</strong> — You control where cached data goes</li>
  <li><strong>Type safety</strong> — Compiler enforces correct usage</li>
  <li><strong>No hidden state</strong> — No implicit global caches</li>
  <li><strong>Testability</strong> — Easy to mock and verify</li>
</ol>

<h3 id="feeder-lifecycle">Feeder Lifecycle</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Create feeder with entity ID
        ↓
2. Pass feeder to cache expander
        ↓
3. Cache expander calls entity_id()
        ↓
4. Cache hit → feed() called with entity
   Cache miss → fetch from repository → feed() called
        ↓
5. Application reads entity from feeder
</code></pre></div></div>

<h3 id="example-using-a-feeder">Example: Using a Feeder</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Create feeder with the ID you want to fetch</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="s">"user_001"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="n">user</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 2. Execute cache operation</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// 3. Access the result</span>
<span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span> <span class="n">feeder</span><span class="py">.user</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Found user: {}"</span><span class="p">,</span> <span class="n">user</span><span class="py">.name</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"User not found"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="cache-strategies">Cache Strategies</h2>

<p>cache-kit provides four explicit cache strategies:</p>

<h3 id="1-fresh-cache-only">1. Fresh (Cache-Only)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Fresh</span>
</code></pre></div></div>

<ul>
  <li><strong>Behavior:</strong> Return entity from cache, or <code class="language-plaintext highlighter-rouge">None</code> if not cached</li>
  <li><strong>Use case:</strong> When you ONLY want cached data, never database</li>
  <li><strong>Example:</strong> Real-time dashboards showing last known state</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Fresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="k">match</span> <span class="n">feeder</span><span class="py">.user</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached user: {}"</span><span class="p">,</span> <span class="n">user</span><span class="py">.name</span><span class="p">),</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Not in cache"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-refresh-cache--database-fallback">2. Refresh (Cache + Database Fallback)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span>
</code></pre></div></div>

<ul>
  <li><strong>Behavior:</strong> Try cache first, fallback to database on miss, then cache the result</li>
  <li><strong>Use case:</strong> <strong>Default and recommended</strong> for most operations</li>
  <li><strong>Example:</strong> User profile lookups, product details</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Will always have data (if it exists in DB)</span>
<span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span> <span class="n">feeder</span><span class="py">.user</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"User: {}"</span><span class="p">,</span> <span class="n">user</span><span class="py">.name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-invalidate-clear--refresh">3. Invalidate (Clear + Refresh)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span>
</code></pre></div></div>

<ul>
  <li><strong>Behavior:</strong> Remove from cache, fetch from database, cache the fresh result</li>
  <li><strong>Use case:</strong> After updates/writes to ensure fresh data</li>
  <li><strong>Example:</strong> After user updates profile</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// User updated their profile</span>
<span class="n">repository</span><span class="nf">.update_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">updated_user</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="c1">// Invalidate cache and fetch fresh data</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="4-bypass-database-only">4. Bypass (Database-Only)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Bypass</span>
</code></pre></div></div>

<ul>
  <li><strong>Behavior:</strong> Skip cache entirely, always fetch from database</li>
  <li><strong>Use case:</strong> One-off queries, debugging, auditing</li>
  <li><strong>Example:</strong> Admin operations that need guaranteed fresh data</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Always fetch from database, ignore cache</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Bypass</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="strategy-decision-tree">Strategy Decision Tree</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Need data?
  ├─ Only cached? → Fresh
  ├─ Fresh from DB required? → Invalidate or Bypass
  ├─ Normal read? → Refresh (default)
  └─ Debugging? → Bypass
</code></pre></div></div>

<hr />

<h2 id="data-repository-pattern">Data Repository Pattern</h2>

<p>cache-kit is agnostic to your data source. You define how to fetch entities:</p>

<h3 id="the-datarepository-trait">The DataRepository Trait</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="n">DataRepository</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CacheEntity</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">T</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-sqlx-repository">Example: SQLx Repository</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">sqlx</span><span class="p">::</span><span class="n">PgPool</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">UserRepository</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="n">PgPool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UserRepository</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">block_in_place</span><span class="p">(||</span> <span class="p">{</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">runtime</span><span class="p">::</span><span class="nn">Handle</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.block_on</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">user</span> <span class="o">=</span> <span class="nn">sqlx</span><span class="p">::</span><span class="nd">query_as!</span><span class="p">(</span>
                    <span class="n">User</span><span class="p">,</span>
                    <span class="s">"SELECT id, name, email FROM users WHERE id = $1"</span><span class="p">,</span>
                    <span class="n">id</span>
                <span class="p">)</span>
                <span class="nf">.fetch_optional</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.pool</span><span class="p">)</span>
                <span class="k">.await</span>
                <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nn">Error</span><span class="p">::</span><span class="nf">RepositoryError</span><span class="p">(</span><span class="n">e</span><span class="nf">.to_string</span><span class="p">()))</span><span class="o">?</span><span class="p">;</span>

                <span class="nf">Ok</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-in-memory-repository-for-testing">Example: In-Memory Repository (for Testing)</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">InMemoryRepository</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">User</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">InMemoryRepository</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">data</span><span class="nf">.get</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">.cloned</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="repository-best-practices">Repository Best Practices</h3>

<p>✅ <strong>DO:</strong></p>
<ul>
  <li>Keep repositories focused on data fetching only</li>
  <li>Return <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> to distinguish “not found” from errors</li>
  <li>Use proper error types (convert DB errors to cache-kit errors)</li>
  <li>Make repositories cloneable (<code class="language-plaintext highlighter-rouge">Arc</code> wrapper)</li>
</ul>

<p>❌ <strong>DON’T:</strong></p>
<ul>
  <li>Put cache logic inside repositories</li>
  <li>Mix business logic with data access</li>
  <li>Assume entities exist (always return Option)</li>
  <li>Panic on database errors</li>
</ul>

<hr />

<h2 id="cache-ownership-and-invalidation">Cache Ownership and Invalidation</h2>

<p>You own cache invalidation. cache-kit does not:</p>

<ul>
  <li>Automatically invalidate on writes</li>
  <li>Track entity relationships</li>
  <li>Provide distributed invalidation</li>
  <li>Guess when data is stale</li>
</ul>

<h3 id="invalidation-patterns">Invalidation Patterns</h3>

<h4 id="pattern-1-invalidate-after-write">Pattern 1: Invalidate After Write</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">UserService</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_user</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">user</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">User</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 1. Update database</span>
        <span class="k">self</span><span class="py">.repository</span><span class="nf">.update</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// 2. Invalidate cache</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="n">user</span><span class="py">.id</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">user</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">self</span><span class="py">.cache_expander</span><span class="nf">.with</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.repository</span><span class="p">,</span>
            <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span>
        <span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="pattern-2-ttl-based-expiry">Pattern 2: TTL-Based Expiry</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="c1">// Set TTL when caching</span>
<span class="k">let</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
    <span class="nf">.with_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
    <span class="nf">.with_ttl</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>  <span class="c1">// 5 minutes</span>
    <span class="nf">.build</span><span class="p">();</span>

<span class="c1">// Data automatically expires after 5 minutes</span>
<span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="pattern-3-event-driven-invalidation">Pattern 3: Event-Driven Invalidation</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// When user updates profile via event</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">on_user_updated</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">UserUpdatedEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">UserFeeder</span> <span class="p">{</span>
        <span class="n">id</span><span class="p">:</span> <span class="n">event</span><span class="py">.user_id</span><span class="p">,</span>
        <span class="n">user</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// Clear cache for this user</span>
    <span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Invalidate</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="putting-it-all-together">Putting It All Together</h2>

<p>Here’s how all concepts work together:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">cache_kit</span><span class="p">::{</span>
    <span class="n">CacheEntity</span><span class="p">,</span> <span class="n">CacheFeed</span><span class="p">,</span> <span class="n">DataRepository</span><span class="p">,</span> <span class="n">CacheExpander</span><span class="p">,</span>
    <span class="nn">backend</span><span class="p">::</span><span class="n">InMemoryBackend</span><span class="p">,</span>
    <span class="nn">strategy</span><span class="p">::</span><span class="n">CacheStrategy</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">serde</span><span class="p">::{</span><span class="n">Deserialize</span><span class="p">,</span> <span class="n">Serialize</span><span class="p">};</span>

<span class="c1">// 1. Entity (Serializable)</span>
<span class="nd">#[derive(Clone,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">struct</span> <span class="n">Product</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 2. Deterministic cache key</span>
<span class="k">impl</span> <span class="n">CacheEntity</span> <span class="k">for</span> <span class="n">Product</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">cache_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Key</span> <span class="p">{</span> <span class="k">self</span><span class="py">.id</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">cache_prefix</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span> <span class="s">"product"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 3. Explicit cache boundary (Feeder)</span>
<span class="k">struct</span> <span class="n">ProductFeeder</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">product</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CacheFeed</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">ProductFeeder</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">entity_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span> <span class="k">self</span><span class="py">.id</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">feed</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="k">self</span><span class="py">.product</span> <span class="o">=</span> <span class="n">entity</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 4. Data repository</span>
<span class="k">struct</span> <span class="n">ProductRepository</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">DataRepository</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">ProductRepository</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fetch_by_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// Your database logic</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">Product</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="s">"Example Product"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">price</span><span class="p">:</span> <span class="mf">99.99</span><span class="p">,</span>
        <span class="p">}))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Usage</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">cache_kit</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">InMemoryBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">expander</span> <span class="o">=</span> <span class="nn">CacheExpander</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">repository</span> <span class="o">=</span> <span class="n">ProductRepository</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">feeder</span> <span class="o">=</span> <span class="n">ProductFeeder</span> <span class="p">{</span>
        <span class="n">id</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
        <span class="n">product</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// Cache operation with explicit strategy</span>
    <span class="n">expander</span><span class="nf">.with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">feeder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">repository</span><span class="p">,</span> <span class="nn">CacheStrategy</span><span class="p">::</span><span class="n">Refresh</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">product</span><span class="p">)</span> <span class="o">=</span> <span class="n">feeder</span><span class="py">.product</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Product: {} - ${}"</span><span class="p">,</span> <span class="n">product</span><span class="py">.name</span><span class="p">,</span> <span class="n">product</span><span class="py">.price</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="next-steps">Next Steps</h2>

<ul>
  <li><a href="installation">Install and configure</a> cache-kit in your project</li>
  <li>Learn about <a href="database-compatibility">Database &amp; ORM compatibility</a></li>
  <li>Explore <a href="serialization">Serialization options</a></li>
  <li>Review <a href="backends">Cache backend choices</a></li>
</ul>
